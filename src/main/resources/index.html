<!--
 Copyright (c) 2018 Uber Technologies, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html>
<head>
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <style type="text/css">
        html, body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }

        .main {
            display: grid;
            min-height: 100vh;
            grid-template-columns: 50px 1fr;
            grid-template-rows: min-content min-content min-content 1fr min-content;
        }

        .header {
            grid-row: 1;
            grid-column: 2;
        }

        .sampleAxisCanvas {
            position: relative;
            grid-row: 2;
            grid-column: 1;
            width: 100%;
            height: 100%;
        }

        .sampleCanvas {
            position: relative;
            grid-row: 2;
            grid-column: 2;
            height: 250px;
            width: 100%;
        }

        .stateCanvas {
            position: relative;
            grid-row: 3;
            grid-column: 2;
            height: 50px;
            width: 100%;
        }

        .content {
            position: relative;
            grid-row: 4;
            grid-column: 2;
        }

        .footer {
            grid-row: 4;
            grid-column: 2;
        }

        .axisCanvas {
            height: 20px;
            width: 100%;
        }

        .minimapCanvas {
            height: 15px;
            width: 100%;
        }

        .canvas {
            height: 100%;
            width: 100%;
        }

        .details {
            display: none;
            background-color: #303030;
            position: absolute;
            margin: 10px;
            padding: 10px;
            bottom: 0;
        }

        .details-header {
            display: grid;
            grid-template-columns: min-content 1fr min-content;
            margin-bottom: 5px;
            overflow: hidden;
        }

        .details-name {
            grid-column: 1;
            font-family: 'Roboto', sans-serif;
            font-size: 11px;
            color: rgba(255, 255, 255, .7);
            align-self: center;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
            max-width: 325px;
        }

        #inclusive {
            grid-column: 2;
            font-family: 'Roboto 12px', sans-serif;
            align-self: center;
            padding-left: 5px;
            font-size: 13px;
            color: rgba(255, 255, 255, .3);
        }

        .details-focus {
            grid-column: 3;
            background:
                    url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHN0eWxlPi5he3N0cm9rZS13aWR0aDo0O3N0cm9rZTojZmZmO308L3N0eWxlPjxnIGZpbGw9Im5vbmUiPjxjaXJjbGUgY3g9IjMyIiBjeT0iMzIiIHI9IjEwIiBmaWxsPSIjZmZmIi8+PGNpcmNsZSBjeD0iMzIiIGN5PSIzMiIgcj0iMTkiIGNsYXNzPSJhIi8+PHBhdGggZD0ibTUxIDMyaDkiIGNsYXNzPSJhIi8+PHBhdGggZD0ibTMyIDEzdi05IiBjbGFzcz0iYSIvPjxwYXRoIGQ9Im0zMiA2MHYtOSIgY2xhc3M9ImEiLz48cGF0aCBkPSJtNCAzMmg5IiBjbGFzcz0iYSIvPjwvZz48L3N2Zz4=")
                    no-repeat
                    left center;
            cursor: pointer;
            margin-left: 10px;
            width: 20px;
            height: 20px;
            background-size: cover;
            float: right;
            align-self: center;
            opacity: .7;
        }

        .details-focus:hover {
            opacity: .9;
        }

        .details-content {
            display: grid;
            grid-template-rows: max-content repeat(6, min-content);
            grid-template-columns: repeat(4, min-content);
            grid-column-gap: 35px;
        }

        .details-content > * {
            font-family: 'Roboto 12px', sans-serif;
            font-weight: lighter;
            white-space: nowrap;
        }

        .details-sub-header {
            font-size: 11px;
            grid-row: 1;
            margin-bottom: 5px;
            color: rgba(255, 255, 255, .3);
        }

        .details-call-header {
            grid-column: 1/3;
        }

        .details-method-header {
            grid-column: 3/5;
        }

        .details-label {
            font-size: 12px;
            color: rgba(255, 255, 255, .3);
        }

        .details-value {
            font-size: 12px;
            color: rgba(255, 255, 255, .7);
            justify-self: end;
        }

        .details-method {
            /*opacity: .5;*/
        }

        .details-label.details-call {
            grid-column: 1;
        }

        .details-value.details-call {
            grid-column: 2;
        }

        .details-label.details-method {
            grid-column: 3;
        }

        .details-value.details-method {
            grid-column: 4;
        }

        .call-start {
            grid-row: 2;
        }

        .call-end {
            grid-row: 3;
        }

        .call-exclusive {
            grid-row: 4;
        }

        .call-percent {
            grid-row: 5;
        }

        .method-total-duration {
            grid-row: 2;
        }

        .method-avg-duration {
            grid-row: 3;
        }

        .method-call-count {
            grid-row: 4;
        }

        .method-percent {
            grid-row: 5;
        }

        .progress {
            height: 5px;
            width: 100%;
            transform: scale(0, 1);
            transform-origin: left;
            /* Transitions are janky for some reason */
            /*transition: 100ms linear;*/
            /*transition-property: transform;*/
            background-color: green;
        }

        .searchIcon {
            border: transparent solid 10px;
            background:
                    url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgdmlld0JveD0iMCAwIDI1NiAyNTYiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48Y2lyY2xlIHN0cm9rZT0iI0ZGRiIgc3Ryb2tlLXdpZHRoPSIyMCIgY3g9Ijk2IiBjeT0iOTYiIHI9Ijg1Ii8+PHBhdGggZD0iTTE0Ny44OTMgMTY5LjEwN2wyMS4yMTQtMjEuMjE0IDc1Ljc0NiA3NS43NDdjMy45MDUgMy45MDUgMy45MDUgMTAuMjM3IDAgMTQuMTQybC03LjA3MSA3LjA3Yy0zLjkwNSAzLjkwNi0xMC4yMzcgMy45MDYtMTQuMTQyIDBsLTc1Ljc0Ny03NS43NDV6IiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==")
                    no-repeat
                    left center;
            background-size: cover;
            width: 20px;
            height: 20px;
            opacity: .7;
            margin-right: 10px;
            float: right;
            cursor: pointer;
        }

        .searchIcon:hover {
            opacity: .9;
        }

        .searchModal {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .searchPanel {
            outline: none;
            position: absolute;
            right: 0;
            top: 0;
            width: 300px;
            height: 100%;
            background: #111;
            float: right;
            padding: 20px;
        }

        .search {
            width: 100%;
            outline: none;
            border: none;
            background-color: #00000000;
            color: white;
            font-size: 20px;
        }

        .searchResultRow {
            font-family: 'Roboto', sans-serif;
            font-size: 12px;
            padding-left: 10px;
            padding-top: 5px;
            padding-bottom: 5px;
            cursor: pointer;
            color: #FFF9;
            border-bottom: #FFF5 solid 1px;
        }

        .searchResultRow:hover {
            background-color: darkgray;
        }

        .file {
            position: absolute;
            bottom: 0;
            left: 0;
        }

        .title {
            position: absolute;
            left: 0;
            top: 0;
            margin: 15px;
            color: #aaa;
            font-family: 'Roboto 12px', sans-serif;
            font-weight: lighter;
        }
    </style>
</head>
<body>
<div class="main">
    <div class="header">
        <div id="progress" class="progress"></div>
        <input type="file" class="file" id="file" name="file">
        <div id="searchIcon" class="searchIcon"></div>
        <canvas class="axisCanvas" id="axisCanvas"></canvas>
        <div class="title">Nanoscope</div>
    </div>
    <canvas class="sampleAxisCanvas" id="sampleAxisCanvas"></canvas>
    <canvas class="sampleCanvas" id="sampleCanvas"></canvas>
    <canvas class="stateCanvas" id="stateCanvas"></canvas>
    <div class="content">
        <canvas class="canvas" id="canvas"></canvas>
        <div class="details" id="details">
            <div class="details-header">
                <div class="details-name">DisplayEventReceiver.dispatchVsync</div>
                <div id="inclusive">(98.234ms)</div>
                <div class="details-focus"></div>
            </div>

            <div class="details-content">
                <div class="details-sub-header details-call-header">CALL STATS</div>
                <div class="details-call details-label call-start">Start</div><div class="details-call details-value call-start">0.758</div>
                <div class="details-call details-label call-end">End</div><div class="details-call details-value call-end">100.726</div>
                <div class="details-call details-label call-exclusive">Exclusive</div><div class="details-call details-value call-exclusive">7.498</div>
                <div class="details-call details-label call-percent">% of whole</div><div class="details-call details-value call-percent">0.035%</div>

                <div class="details-sub-header details-method-header">METHOD STATS</div>
                <div class="details-method details-label method-total-duration">Total duration</div><div class="details-method details-value method-total-duration">1984.758</div>
                <div class="details-method details-label method-avg-duration">Avg duration</div><div class="details-method details-value method-avg-duration">75.726</div>
                <div class="details-method details-label method-call-count">Call count</div><div class="details-method details-value method-call-count">23</div>
                <div class="details-method details-label method-percent">% of whole</div><div class="details-method details-value method-percent">0.035%</div>
            </div>
        </div>
    </div>
    <div class="footer">
        <canvas class="minimapCanvas" id="minimapCanvas"></canvas>
    </div>
    <div id="searchModal" class="searchModal">
        <div id="searchPanel" class="searchPanel">
            <input type="text" id="search" class="search" name="search">
            <div id="searchResults" class="searchResults"></div>
        </div>
    </div>
</div>
<script type="text/plain" id="sampledata">TRACE_DATA_PLACEHOLDER</script>
<script type="text/plain" id="tracedata">TRACE_DATA_PLACEHOLDER</script>
<script type="text/plain" id="statedata">TRACE_DATA_PLACEHOLDER</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix-min.js"></script>

<script type="text/javascript">
    'use strict';

    const PIXEL_RATIO = (function () {
        let context = canvas.getContext("2d"),
            dpr = window.devicePixelRatio || 1,
            bsr = context.webkitBackingStorePixelRatio ||
                context.mozBackingStorePixelRatio ||
                context.msBackingStorePixelRatio ||
                context.oBackingStorePixelRatio ||
                context.backingStorePixelRatio || 1;

        return dpr / bsr;
    })();

    const THEME = {
        'AXIS_LINE_COLOR': '#666',
        'AXIS_LINE_STROKE_WIDTH': PIXEL_RATIO,
        'AXIS_BACKGROUND_COLOR': '#181818',
        'SAMPLE_BACKGROUND_COLOR': '#ffffff',
        'AXIS_HEIGHT': PIXEL_RATIO * 20,
        'VIEW_PORT_COLOR': "#081016",
        'EVENT_BORDER_COLOR': '#2a555f',
        'EVENT_HEIGHT': 40,
        'COLOR_PALETTE':
            [
                '#429199',
                '#163E42',
                '#59507E',
                '#5A735A',
                '#7F4B6D',
                '#2647AC',
                '#216E56',
                '#6D3562',
                '#2A5B74',
                '#4C597F',
                '#664473',
                '#152555',
                '#5879DA',
                '#195188',
                '#1C8EB4',
                '#0E7077',
                '#4D4D4D',
                '#717171',
            ],
        'COLOR_PALETTE_STATE':
            [
              '#970c2a',
              '#1d6808',
              '#12deb2',
              '#c61093',
              '#9e10c6',
              '#0c9779',
              '#4fc4f1',
              '#61caf2',
              '#73d0f4',
              '#85d6f5',
              '#98dcf7',
              '#aae2f8',
              '#bce8fa',
              '#ceeefb',
              '#e0f5fd',
              '#f2fbfe',
              '#3dbdf0',
              '#2bb7ee',
              '#18b1ed',
              '#12a6e0',
              '#1098ce',
              '#0f8bbb',
              '#97790c',
              '#2a970c',
              '#0c2a97',
            ],
            "MARGIN_AROUND_METHODS_AT_START": 0.10,
        "SELECTED_CROSSHAIR_COLOR": "#FFFFFFDD",
        'THREAD_STATE_NAME':
        [
              'Terminated',
              'Runnable',
              'TimedWaiting',
              'Sleeping',
              'Blocked',
              'Waiting',
              'WaitingForGcToComplete',
              'WaitingForCheckPointsToRun',
              'WaitingPerformingGc',
              'WaitingForDebuggerSend',
              'WaitingForDebuggerToAttach',
              'WaitingInMainDebuggerLoop',
              'WaitingForDebuggerSuspension',
              'WaitingForJniOnLoad',
              'WaitingForSignalCatcherOutput',
              'WaitingInMainSignalCatcherLoop',
              'WaitingForDeoptimization',
              'WaitingForMethodTracingStart',
              'WaitingForVisitObjects',
              'WaitingForGetObjectsAllocated',
              'WaitingWeakGcRootRead',
              'WaitingForGcThreadFlip',
              'Starting',
              'Native',
              'Suspended',
        ],
    };

    // Processes raw trace data bytes. Consume processed data by registering callbacks:
    //     onProgress(bytesRead), onDone(), onPush(call), onPop(call)
    class TraceDataProcessor {

        constructor(bytes) {
            this.charZero = '0'.charCodeAt(0);
            this.charColon = ':'.charCodeAt(0);
            this.charNewline = '\n'.charCodeAt(0);
            this.charMetaDataDelimiter = '#'.charCodeAt(0);
            this.charNoParse = '+'.charCodeAt(0);
            this.charPeriod = '.'.charCodeAt(0);
            this.charLeftParen = '('.charCodeAt(0);

            this.onProgress = () => {
            };
            this.onDone = () => {
            };
            this.onPush = () => {
            };
            this.onPop = () => {
            };
            this.callStack = [];
            // this.firstTimestamp = -1;
            this.firstTimestamp = 0;
            this.timestamp = -1;
            this.done = false;
            this.totalBytes = bytes.length;
            this.bytesRead = 0;

            let it = bytes.values();
            this.next = () => {
                this.bytesRead++;
                return it.next();
            };
        }

        load() {
            this.loop();
        }

        loop() {
            this.loadWithDeadline(this.createDeadline());
            if (this.done) {
                this.onProgress(this.totalBytes);
                this.onDone();
            } else {
                this.onProgress(this.bytesRead);
                requestAnimationFrame(this.loop.bind(this));
            }
        }

        createDeadline() {
            let timeout = 500;
            let deadline = Date.now() + timeout;
            return {
                timeRemaining: () => deadline - Date.now()
            };
        };

        loadWithDeadline(deadline = {timeRemaining: () => 1}) {
            while (!this.done && deadline.timeRemaining() > 0) {
                this.loadLine();
            }
            if (this.done) {
                while (this.callStack.length > 0) {
                    this.pop();
                }
            }
        }

        loadLine() {
            let loadedTimestamp = this.loadTimestamp();
            if (this.done) {
                return;
            }
            this.timestamp = loadedTimestamp;
            let namesAndMeta = this.loadNameAndMeta();
            let name = namesAndMeta[0];
            let shortName = namesAndMeta[1];
            let meta = namesAndMeta[2];
            // if (this.firstTimestamp === -1) {
            //     this.firstTimestamp = this.timestamp;
            // }
            this.timestamp -= this.firstTimestamp;
            if (name === "POP") {
                if (this.callStack.length > 0) {
                    this.pop();
                }
            } else {
                let stackDepth = this.callStack.length + 1;
                let call = new TraceCall(name, shortName, meta, stackDepth, this.timestamp);
                this.callStack.push(call);
                this.onPush(call);
            }
        }

        pop() {
            let call = this.callStack.pop();
            call.end = this.timestamp;
            this.onPop(call);
        }

        loadTimestamp() {
            let next = this.next();
            if (next.done) {
                this.done = true;
                return;
            }

            let timestamp = 0;
            while (next.value !== this.charColon) {
                timestamp *= 10;
                timestamp += next.value - this.charZero;
                next = this.next();
            }
            return timestamp;
        }

        loadNameAndMeta() {
            let name = "";
            let shortName = "";
            let meta = "";
            let next = this.next();
            let index = 0;
            let periods = [];
            if (next.value === this.charNoParse) {
                next = this.next();
                while (!next.done && next.value !== this.charNewline) {
                    name += String.fromCharCode(next.value);
                    next = this.next();
                }
                shortName = name;
            } else {
                while (!next.done && next.value !== this.charNewline && next.value !== this.charMetaDataDelimiter) {
                    if (!shortName) {
                        if (next.value === this.charPeriod) {
                            if (periods.size < 2) {
                                periods.push(index);
                            } else {
                                periods[0] = periods[1];
                                periods[1] = index;
                            }
                        } else if (next.value === this.charLeftParen) {
                            shortName = name.substring(periods[0] + 1, index)
                        }
                    }
                    name += String.fromCharCode(next.value);
                    next = this.next();
                    index++;
                }
                if (next.value === this.charMetaDataDelimiter) {
                    next = this.next();
                }
                while (!next.done && next.value !== this.charNewline) {
                    meta += String.fromCharCode(next.value);
                    next = this.next();
                }
            }
            return [name, shortName, meta];
        }
    }

    // Caches rasterized text.
    class TextPool {

        constructor() {
            this.canvases = {};
            this.font = '18px Roboto';
        }

        getOrRasterize(name) {
            let canvas = this.canvases[name];
            if (canvas) {
                return canvas;
            }

            canvas = this._rasterize(name);
            this.canvases[name] = canvas;
            return canvas;
        }

        _rasterize(name) {
            let canvas = document.createElement('canvas');
            let context = canvas.getContext('2d');

            context.fillStyle = "white";
            context.font = this.font;
            context.textBaseline = 'middle';
            let textSize = context.measureText(name);
            let textWidth = textSize.width;
            let textHeight = THEME.EVENT_HEIGHT;
            canvas.width = textWidth * PIXEL_RATIO;
            canvas.height = textHeight;

            context.fillStyle = "rgba(255, 255, 255, 0.8)";
            context.font = this.font;
            context.textBaseline = 'middle';
            context.fillText(name, 0, canvas.height / 2);
            return canvas;
        }
    }

    // Represents a single invocation of a method.
    class TraceCall {

        constructor(name, shortName, meta, stackDepth, start) {
            this.name = name;
            this.shortName = shortName;
            this.meta = meta;
            this.stackDepth = stackDepth;
            this.start = start;
            this.end = null;
            this.method = null;
        }
    }

    // Represents a method. Multiple TraceCalls can be associated with a single TraceMethod.
    class TraceMethod {

        constructor(callPrototype) {
            this.name = callPrototype.name;
            this.shortName = callPrototype.shortName;
            // Total duration - Does not include recursive calls.
            this.totalDuration = 0;
            // Total duration - Includes recursive calls.
            this.totalRecursiveDuration = 0;
            // Keeps track of the per-method call stack so we don't include recursive calls in this.totalDuration.
            this.callStack = [];
            this.calls = [];
        }

        getCallAt(index) {
            return this.calls[index];
        }

        pushCall(call) {
            this.callStack.push(call);
            this.calls.push(call);
        }

        popCall(call) {
            let popped = this.callStack.pop();
            if (popped !== call) {
                console.error("TraceMethod: Inconsistent popCall.");
                return;
            }

            let callDuration = call.end - call.start;
            this.totalRecursiveDuration += callDuration;
            if (this.callStack.length === 0) {
                this.totalDuration += callDuration;
            }
        }
    }

    // Holds all TraceMethod information for a trace file. Maps method names to calls.
    class MethodRegistry {

        constructor() {
            this.methods = {};
            this.data = "\"";
            this.minTimestamp = 0;
            this.maxTimestamp = 0;
            this.maxStackDepth = 1;
        }

        pushCall(call) {
            let method = this.methods[call.name];
            if (!method) {
                method = new TraceMethod(call);
                this.methods[call.name] = method;
                this.data += call.name;
                this.data += "\"";
            }
            call.method = method;

            method.pushCall(call);

            if(this.minTimestamp === 0){
                this.minTimestamp = call.start;
            }
            this.minTimestamp = Math.min(this.minTimestamp, call.start);
            this.maxStackDepth = Math.max(this.maxStackDepth, call.stackDepth);
        }

        popCall(call) {
            let method = this.methods[call.name];
            if (!method) {
                console.error("MethodRegistry: Unexpected popCall.");
            }

            method.popCall(call);

            this.maxTimestamp = Math.max(this.maxTimestamp, call.end);
        }

        search(query, limit = 10) {
            if (query.length === 0) {
                return [];
            }
            let rx = new RegExp('"([^"]*' + query + '[^"]*)"', 'gi');
            let i = 0, results = [], result;
            while (result = rx.exec(this.data)) {
                if (i++ > limit) {
                    break;
                }
                let name = result[1];
                results.push(this.methods[name]);
            }

            return results;
        }

        getMethod(name) {
            return this.methods[name];
        }
    }

    class Rect {

        constructor(left, top, width, height) {
            this.left = left;
            this.top = top;
            this.width = width;
            this.height = height;
        }
    }

    // Abstraction over underlying transformation matrix.
    class Transform {

        constructor() {
            this.matrix = mat3.create();
            this.screenViewport = new Rect(0, 0, 0, 0);

            this.inverse = mat3.create();
            this.viewport = new Rect(0, 0, 0, 0);
            this.minXScale = 0;
        }

        applyTo(context) {
            context.setTransform(this.matrix[0], this.matrix[1], this.matrix[3], this.matrix[4], this.matrix[6], this.matrix[7]);
        }

        setMaxZoomFromModelWidth(duration) {
            // The screen content should never take up a tiny portion of the screen. The screen
            // looks silly when this happens.
            this.minXScale = this.screenViewport.width / duration / (1 + 2 * THEME.MARGIN_AROUND_METHODS_AT_START);
        }

        setScreenViewport(screenViewport) {
            this.screenViewport = screenViewport;
            this._refresh();
        }

        getViewport() {
            return this.viewport;
        }

        getScreenViewport() {
            return this.screenViewport;
        }

        getScaleX() {
            return this.matrix[0];
        }

        getScaleY() {
            return this.matrix[4];
        }

        getTranslationX() {
            return this.matrix[6];
        }

        getTranslationY() {
            return this.matrix[7];
        }

        toScreenPosition(modelPosition) {
            return vec2.transformMat3(vec2.create(), modelPosition, this.matrix);
        }

        toModelPosition(screenPosition) {
            return vec2.transformMat3(vec2.create(), screenPosition, this.inverse);
        }

        focus(left, top, width) {
            let scale = this.screenViewport.width / width;
            mat3.fromScaling(this.matrix, vec2.fromValues(scale, 1));
            mat3.translate(this.matrix, this.matrix, vec2.fromValues(-left, -top));
            this._refresh();
        }

        _scroll(dx, dy) {
            let translation = vec2.fromValues(dx / this.getScaleX(), dy);
            mat3.translate(this.matrix, this.matrix, translation);
            // Enforce top bounds: no reason we should allow the user to scroll well beyond the top of the screen.
            this.matrix[7] = Math.min(this.screenViewport.top / this.matrix[4], this.matrix[7]);
            this._refresh();
        }

        _scale(scale, x, y) {
            let K = 10;
            let originalScreenPoint = vec2.fromValues(x, y);
            let originalModelPoint = this.toModelPosition(originalScreenPoint);
            scale = Math.sign(scale) * Math.min(K, Math.abs(scale)) / K + 1;
            mat3.scale(this.matrix, this.matrix, vec2.fromValues(scale, 1));
            this.matrix[0] = Math.max(this.minXScale, this.matrix[0]);
            let newScreenPoint = this.toScreenPosition(originalModelPoint);
            let offsetX = originalScreenPoint[0] - newScreenPoint[0];
            let offsetY = originalScreenPoint[1] - newScreenPoint[1];
            mat3.translate(this.matrix, this.matrix, vec2.fromValues(offsetX / this.matrix[0], offsetY));
            this._refresh();
        }

        toModelPositionFromClick(event) {
            let boundingRect = canvas.getBoundingClientRect();
            let x = event.clientX - boundingRect.left;
            let y = event.clientY - boundingRect.top;
            x *= PIXEL_RATIO;
            y *= PIXEL_RATIO;
            return this.toModelPosition(vec2.fromValues(x, y));
        }

        onMouseWheel(event) {
            if (event.ctrlKey) {
                let boundingRect = canvas.getBoundingClientRect();
                let x = event.clientX - boundingRect.left;
                let y = event.clientY - boundingRect.top;
                x *= PIXEL_RATIO;
                y *= PIXEL_RATIO;
                this._scale(-event.deltaY / 10, x, y);
            } else {
                this._scroll(-event.deltaX, -event.deltaY);
            }
        }

        onKeyPress(keyCode) {
            let SCROLL_JUMP = 200;
            let SCALE_JUMP = 4;
            if (keyCode === 65) { // a
                this._scroll(SCROLL_JUMP, 0);
            } else if (keyCode === 68) { // d
                this._scroll(-SCROLL_JUMP, 0);
            } else if (keyCode === 87) { // w
                let boundingRect = canvas.getBoundingClientRect();
                this._scale(SCALE_JUMP, (boundingRect.left + boundingRect.right) / 2 * PIXEL_RATIO,
                    boundingRect.top + boundingRect.height / 2 * PIXEL_RATIO);
            } else if (keyCode === 83) { // s
                let boundingRect = canvas.getBoundingClientRect();
                this._scale(-SCALE_JUMP, (boundingRect.left + boundingRect.right) / 2 * PIXEL_RATIO,
                    boundingRect.top + boundingRect.height / 2 * PIXEL_RATIO);
            } else {
                return false;
            }
            return true;
        }

        _refresh() {
            let screenLeftTop = vec2.fromValues(this.screenViewport.left, this.screenViewport.top);
            let screenRightBottom = vec2.fromValues(screenLeftTop[0] + this.screenViewport.width, screenLeftTop[1] + this.screenViewport.height);

            let inverse = mat3.invert(mat3.create(), this.matrix);
            let viewportLeftTop = vec2.transformMat3(vec2.create(), screenLeftTop, inverse);
            let viewportRightBottom = vec2.transformMat3(vec2.create(), screenRightBottom, inverse);

            let left = viewportLeftTop[0];
            let top = viewportLeftTop[1];
            let width = viewportRightBottom[0] - left;
            let height = viewportRightBottom[1] - top;

            this.viewport = new Rect(left, top, width, height);
            mat3.invert(this.inverse, this.matrix);
        }
    }

    // Handles displaying trace loading progress.
    class LoadingController {

        constructor() {
            this.progressEl = document.getElementById('progress');
        }

        onStart(totalBytes) {
            this.totalBytes = totalBytes;
            this.progressEl.style.transform = `scale(0, 1)`;
        }

        onProgress(bytesRead) {
            let scale = bytesRead / this.totalBytes;
            this.progressEl.style.transform = `scale(${scale}, 1)`;
        }

        onDone() {
            this.progressEl.style.transform = `scale(0, 1)`;
        }
    }

    // Handles displaying details of selected TraceCall.
    class DetailsController {

        constructor() {
            this.el = document.getElementById('details');
            this.nameEl = this.el.querySelector('.details-name');
            this.focusEl = this.el.querySelector('.details-focus');

            this.callStartEl = this.el.querySelector('.call-start.details-value');
            this.callEndEl = this.el.querySelector('.call-end.details-value');
            this.callInclusiveEl = document.getElementById('inclusive');
            this.callExclusiveEl = this.el.querySelector('.call-exclusive.details-value');
            this.callPercentEl = this.el.querySelector('.call-percent.details-value');

            this.methodTotalDurationEl = this.el.querySelector('.method-total-duration.details-value');
            this.methodAvgDurationEl = this.el.querySelector('.method-avg-duration.details-value');
            this.methodCallCountEl = this.el.querySelector('.method-call-count.details-value');
            this.methodPercentEl = this.el.querySelector('.method-percent.details-value');

            this.methodRegistry = new MethodRegistry();
            this.selectedCall = null;
            this.onFocus = () => {};

            this.focusEl.addEventListener('click', () =>{
                if (this.selectedCall) {
                    this.onFocus(this.selectedCall);
                }
            });
        }

        setMethodRegistry(methodRegistry) {
            this.methodRegistry = methodRegistry;
        }

        selectCall(call) {
            this.selectedCall = call;
            if (call.meta !== "") {
                // If the meta descriptor has a slash in it we take all the content after the slash.
                let metaParts = call.meta.split('/');
                let metaShort = metaParts[metaParts.length -1];
                this.nameEl.innerHTML = call.shortName + "</br><i>" + metaShort + "</i>";
            } else {
                this.nameEl.innerText = call.shortName;
            }

            this.el.style.display = 'inline';

            let callDuration = call.end - call.start;
            this.callStartEl.innerText = DetailsController._formatNs(call.start);
            this.callEndEl.innerText = DetailsController._formatNs(call.end);
            this.callInclusiveEl.innerText = `(${DetailsController._formatDuration(callDuration)})`;
            this.callExclusiveEl.innerText = '<todo>';

            let totalTraceDuration = this.methodRegistry.maxTimestamp - this.methodRegistry.minTimestamp;
            this.callPercentEl.innerHTML = DetailsController._format(100 * callDuration / totalTraceDuration) + '%';

            let method = call.method;
            let methodTotalDuration = method.totalDuration;
            this.methodTotalDurationEl.innerText = DetailsController._formatDuration(methodTotalDuration);
            this.methodAvgDurationEl.innerText = DetailsController._formatDuration(method.totalRecursiveDuration / method.calls.length);
            this.methodCallCountEl.innerText = method.calls.length.toString();
            this.methodPercentEl.innerText = DetailsController._format(100 * methodTotalDuration / totalTraceDuration) + '%';
        }

        static _formatDuration(number) {
            if (number < 1000) {
                return number + "ns";
            } else if (number < 1000 * 1000) {
                return Number(number / 1000.0).toFixed(2).toString() + "\u03BCs"
            } else {
                return Number(number / 1000.0 / 1000).toFixed(2).toString() + "ms"
            }
        }

        static _format(number, places = 2) {
            return Number(number).toFixed(places).toString();
        }

        static _formatNs(number) {
            return number + "ns";
        }
    }

    // Represents a single row on the canvas.
    class CanvasRowData {

        constructor() {
            this.calls = [];
        }

        addCall(call) {
            this.calls.push(call);
        }

        visitCalls(viewport, run) {
            let leftIndex = this._getLeftIndex(viewport);
            let rightIndex = this._getRightIndex(viewport);
            for (let i = leftIndex; i <= rightIndex; i++) {
                run(this.calls[i]);
            }
        }

        getCallAtCoordOrNull(x) {
            let rightIndex = CanvasRowData._binarySearch(this.calls, call => call.end, item => item > x);
            let call = this.calls[rightIndex];
            if (call.start <= x && call.end >= x) {
                return call;
            }
            return null;
        }

        _getLeftIndex(viewport) {
            let leftIndex = CanvasRowData._binarySearch(this.calls, call => call.start, item => item >= viewport.left);
            leftIndex = Math.max(leftIndex - 1, 0);
            return leftIndex;
        }

        _getRightIndex(viewport) {
            let rightIndex = CanvasRowData._binarySearch(this.calls, call => call.end, item => item >= viewport.left + viewport.width);
            rightIndex = Math.min(rightIndex, this.calls.length - 1);
            return rightIndex;
        }

        static _binarySearch(array, map, pred) {
            let lo = -1, hi = array.length;
            while (1 + lo !== hi) {
                const mi = lo + ((hi - lo) >> 1);
                if (pred(map(array[mi]))) {
                    hi = mi;
                } else {
                    lo = mi;
                }
            }
            return hi;
        }
    }

    // Represents the trace data for a given canvas zoom level.
    class CanvasZoomData {

        constructor() {
            this.rows = [];
        }

        addCall(call) {
            while (this.rows.length < call.stackDepth) {
                this.rows.push(new CanvasRowData());
            }
            this.rows[call.stackDepth - 1].addCall(call);
        }

        visitCalls(viewport, run) {
            let stackDepth = 1;
            for (let row of this.rows) {
                let rowTop = CanvasTraceData.getRowTop(stackDepth++);
                let rowBottom = rowTop + CanvasTraceData.getRowHeight();
                if (rowTop < viewport.top + viewport.height && rowBottom > viewport.top) {
                    row.visitCalls(viewport, run);
                }
            }
        }

        getCallAtCoordOrNull(x, y) {
            let rowIndex = CanvasTraceData.getRowIndex(y);
            if (rowIndex >= this.rows.length) {
                return null;
            }
            let row = this.rows[rowIndex];
            return row.getCallAtCoordOrNull(x);
        }
    }

    // Represents the trace data for all zoom levels.
    class CanvasTraceData {

        constructor() {
            this.clear();
        }

        addCall(call) {
            for (let zoomData of this.zoomDatas) {
                if (call.end - call.start >= zoomData.minCallDuration) {
                    zoomData.addCall(call);
                }
            }
        }

        clear() {
            this.zoomDatas = [];
            this.zoomCount = 10;

            let viewportWidth = 1000;
            let maxCallsPerRow = 10000;
            let zoomFactor = 10;

            for (let i = 0; i < this.zoomCount; i++) {
                let zoomData = new CanvasZoomData();
                zoomData.minCallDuration = viewportWidth / maxCallsPerRow;
                zoomData.viewportWidth = viewportWidth;
                this.zoomDatas.push(zoomData);

                viewportWidth *= zoomFactor;
            }
        }

        getCallAtCoordOrNull(x, y) {
            for (let i = 0; i < this.zoomCount; i++) {
                let call = this.zoomDatas[i].getCallAtCoordOrNull(x, y);
                if (call !== null) {
                    return call;
                }
            }
            return null;
        }

        // Call run(call) for every on-screen TraceCall at the current zoom level.
        visitCalls(viewport, run) {
            this._getZoomData(viewport).visitCalls(viewport, run);
        }

        _getZoomData(viewport) {
            for (let zoomData of this.zoomDatas) {
                if (viewport.width < zoomData.viewportWidth) {
                    return zoomData;
                }
            }
            return this.zoomDatas[this.zoomDatas.length - 1];
        }

        static getRowTop(stackDepth) {
            return (stackDepth - 1) * CanvasTraceData.getRowHeight();
        }

        static getRowIndex(y) {
            return Math.floor(y / CanvasTraceData.getRowHeight());
        }

        static getRowHeight() {
            return THEME.EVENT_HEIGHT;
        }
    }

    // Renders trace data to a canvas.
    class CanvasTraceRenderer {

        constructor(canvas, transform) {
            this.canvas = canvas;
            this.transform = transform;
            this.context = canvas.getContext('2d');
            this.data = new CanvasTraceData();
            this.textPool = new TextPool();
            this.selectedCall = null;
        }

        clear() {
            this.data.clear();
        }

        addCall(call) {
            this.data.addCall(call);
        }

        render() {
            this.context.setTransform(1, 0, 0, 1, 0, 0);
            this.context.fillStyle = "black";
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.transform.applyTo(this.context);

            let viewport = this.transform.getViewport();
            this.data.visitCalls(viewport, call => {
                this._renderCall(viewport, call);
            });
            this._renderSelectedCrosshairs();
            // this._debugViewport();
        }

        focusOnRegistry(methodRegistry) {
            let duration = methodRegistry.maxTimestamp - methodRegistry.minTimestamp;
            this._focusWithMargin(methodRegistry.minTimestamp, 0, duration, THEME.MARGIN_AROUND_METHODS_AT_START);
        }

        setMaxZoomOut(methodRegistry) {
            let duration = methodRegistry.maxTimestamp - methodRegistry.minTimestamp;
            this.transform.setMaxZoomFromModelWidth(duration)
        }

        focus(call) {
            let left = call.start;
            let top = CanvasTraceData.getRowTop(call.stackDepth);
            let width = call.end - call.start;
            this.transform.focus(left, top, width);
        }

        selectCall(call) {
            this.selectedCall = call;
        }

        getCallAtCoordOrNull(x, y) {
            return this.data.getCallAtCoordOrNull(x, y);
        }

        _renderSelectedCrosshairs() {
            if (!this.selectedCall) {
                return;
            }

            let left = this.selectedCall.start;
            let top = CanvasTraceData.getRowTop(this.selectedCall.stackDepth);

            let screenLeftTop = this.transform.toScreenPosition(vec2.fromValues(left, top));
            let screenLeft = screenLeftTop[0];
            let screenTop = screenLeftTop[1];
            let screenViewport = this.transform.screenViewport;

            this.context.setTransform(1, 0, 0, 1, 0, 0);
            this.context.strokeStyle = THEME.SELECTED_CROSSHAIR_COLOR;
            this.context.strokeRect(screenLeft, screenViewport.top, 1, screenViewport.height);
            this.context.strokeRect(screenViewport.left, screenTop, screenViewport.width, 1);
        }

        // Focus on a particular region. With some margin on both sides.
        _focusWithMargin(left, top, width, marginPercent) {
            this.transform.focus(left - width * marginPercent, 0, width * (1 + 2 * marginPercent));
        }

        _debugViewport() {
            let viewport = this.transform.getViewport();
            this.context.strokeStyle = "red";
            this.context.strokeRect(viewport.left, viewport.top, viewport.width, viewport.height);
        }

        _renderCall(viewport, call) {
            let left = call.start;
            let height = CanvasTraceData.getRowHeight();
            let top = CanvasTraceData.getRowTop(call.stackDepth);
            let width = call.end - call.start;

            CanvasTraceRenderer._ensureBackgroundColor(call);
            this.context.fillStyle = call.backgroundColor;
            this.context.fillRect(left, top, width, height);
            if (call === this.selectedCall) {
                this.context.fillStyle = "#fff6";
                this.context.fillRect(left, top, width, height);
            }

            let scale = this.transform.getScaleX();
            let cellScreenWidth = scale * width;
            if (cellScreenWidth < 25) {
                return;
            }

            if (call.textCanvas == null) {
                call.textCanvas = this.textPool.getOrRasterize(call.shortName);
            }

            let nameModelHeight = call.textCanvas.height;
            let nameModelWidth = Math.min(width, call.textCanvas.width / PIXEL_RATIO / scale);

            // Preferred name position - centered on screen with slight offset.
            let nameModelLeft = viewport.left + viewport.width / 2 - 300;

            // Ensure name within left bounds.
            nameModelLeft = Math.max(left, nameModelLeft);
            let nameModelRight = nameModelLeft + nameModelWidth;

            // Ensure name within right bounds.
            nameModelRight = Math.min(left + width, nameModelRight);
            nameModelLeft = nameModelRight - nameModelWidth;

            // let nameModelLeft = this.left;
            // noinspection UnnecessaryLocalVariableJS
            let nameModelTop = top;

            let nameModelPosition = vec2.fromValues(nameModelLeft, nameModelTop);
            let nameScreenPosition = this.transform.toScreenPosition(nameModelPosition);
            let nameScreenWidth = nameModelWidth * scale;

            this.context.save();
            this.context.setTransform(1, 0, 0, 1, 0, 0);
            this.context.drawImage(
                call.textCanvas,
                0, 0, nameScreenWidth, nameModelHeight,
                nameScreenPosition[0], nameScreenPosition[1], nameScreenWidth, nameModelHeight);
            this.context.restore();
        }

        static _ensureBackgroundColor(call) {
            if (call.backgroundColor) {
                return;
            }

            call.backgroundColor = CanvasTraceRenderer._getBackgroundColor(call);
        }

        static _getBackgroundColor(call) {
            let hash = CanvasTraceRenderer._hash(call.shortName);
            let h = hash % THEME.COLOR_PALETTE.length;
            return THEME.COLOR_PALETTE[h];
        }

        static _hash(str) {
            let hash = 5381;
            let i = str.length;
            while (i) {
                hash = (hash * 33) ^ str.charCodeAt(--i);
            }
            return hash >>> 0;
        }
    }

    // Renders the trace minimap.
    class MinimapRenderer {

        constructor(canvas, transform) {
            this.canvas = canvas;
            this.transform = transform;
            this.context = canvas.getContext('2d');
            this.bounds = new Rect(0, 0, 1, 1);
            this.methodRegistry = new MethodRegistry();
            this.rowHeight = 10;
        }

        render() {
            this.context.fillStyle = "grey";
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);

            let viewportBox = this.getViewportBox();
            this.context.fillStyle = "darkgrey";
            this.context.fillRect(viewportBox.left, 0, viewportBox.width, canvas.height);
        }

        setMethodRegistry(methodRegistry) {
            this.methodRegistry = methodRegistry;
        }

        getViewportBox() {
            let viewport = this.transform.getViewport();

            let scaleX = canvas.width / (this.methodRegistry.maxTimestamp - this.methodRegistry.minTimestamp);
            let scaleY = this.rowHeight / CanvasTraceData.getRowHeight();
            let matrix = mat3.fromScaling(mat3.create(), vec2.fromValues(scaleX, scaleY));

            let leftTop = vec2.fromValues(viewport.left, viewport.top);
            let rightBottom = vec2.fromValues(viewport.left + viewport.width, viewport.top + viewport.height);

            let screenLeftTop = vec2.transformMat3(vec2.create(), leftTop, matrix);
            let screenRightBottom = vec2.transformMat3(vec2.create(), rightBottom, matrix);

            let screenLeft = screenLeftTop[0];
            let screenTop = screenLeftTop[1];
            let screenWidth = screenRightBottom[0] - screenLeft;
            let screenHeight = screenRightBottom[1] - screenTop;

            return new Rect(screenLeft, screenTop, screenWidth, screenHeight);
        }
    }

    class Sample {

        constructor(wallTime, cpuTime, majPF, minPF, ctxSwitch, allocBytes, allocObjects) {
            this.wallTime = wallTime;
            this.cpuTime = cpuTime;
            this.majPF = majPF;
            this.minPF = minPF;
            this.ctxSwitch = ctxSwitch;
            this.allocBytes = allocBytes;
            this.allocObjects = allocObjects;
        }
    }

    class SampleData {

        constructor(string) {
            this.array = [];
            // this.firstWallTime = -1;
            this.firstWallTime = 0;
            this.firstCpuTime = -1;
            this.firstMinPF = -1;
            this.firstMajPF = -1;
            this.firstCtxSwitch = -1;
            this.maxCtxSwitch = -1;
            this.maxPF = -1;
            this.maxAllocBytes = -1;
            this.maxAllocObjects = -1;
            string.split("\n").forEach(s => {
                let a = s.split(", ");
                if (a.length >= 2) {
                    let wallTime = parseInt(a[0]);
                    let cpuTime = parseInt(a[1]);
                    let majPF = parseInt(a[2]);
                    let minPF = parseInt(a[3]);
                    let ctxSwitch = parseInt(a[4]);
                    let allocBytes = parseInt(a[5]);
                    let allocObjects = parseInt(a[6]);
                    // if (this.firstWallTime === -1) {
                    //     this.firstWallTime = wallTime;
                    // }
                    if (this.firstCpuTime === -1) {
                        this.firstCpuTime = cpuTime;
                    }
                    if(this.firstCtxSwitch === -1){
                        this.firstCtxSwitch = ctxSwitch;
                    }
                    if(this.firstMinPF === -1){
                        this.firstMinPF = minPF;
                    }
                    if(this.firstMajPF === -1){
                        this.firstMajPF = majPF;
                    }
                    wallTime -= this.firstWallTime;
                    cpuTime -= this.firstCpuTime;
                    ctxSwitch -= this.firstCtxSwitch;
                    minPF -= this.firstMinPF;
                    majPF -= this.firstMajPF;
                    this.array.push(new Sample(wallTime, cpuTime, majPF, minPF,ctxSwitch, allocBytes, allocObjects));
                }
            })
        }

        windows(windowSize) {
            let windows = [];
            let windowStart = 0;
            let cpuWindowStart = 0;
            let ctxWindowStart = 0;
            let majPFWindowStart = 0;
            let minPFWindowStart = 0;

            this.array.forEach(sample => {
                let windowEnd = windowStart + windowSize;
                if (sample.wallTime > windowEnd) {
                    let cpuDuration = sample.cpuTime - cpuWindowStart;
                    let wallDuration = sample.wallTime - windowStart;
                    let cpuUtilization = cpuDuration / wallDuration;
                    let ctxSwitch = sample.ctxSwitch - ctxWindowStart;
                    let majPF = sample.majPF - majPFWindowStart;
                    let minPF = sample.minPF - minPFWindowStart;
                    let allocBytes = sample.allocBytes;
                    let allocObjects = sample.allocObjects;
                    if(ctxSwitch > this.maxCtxSwitch){
                        this.maxCtxSwitch = ctxSwitch
                    }
                    if(majPF + minPF > this.maxPF){
                        this.maxPF = majPF + minPF;
                    }
                    if(allocBytes > this.maxAllocBytes){
                        this.maxAllocBytes = allocBytes;
                    }
                    if(allocObjects > this.maxAllocObjects){
                        this.maxAllocObjects = allocObjects;
                    }
                    let window = new SampleWindow(windowStart, sample.wallTime, cpuUtilization, majPF, minPF, ctxSwitch, allocBytes, allocObjects);
                    windows.push(window);
                    windowStart = sample.wallTime;
                    cpuWindowStart = sample.cpuTime;
                    ctxWindowStart = sample.ctxSwitch;
                    minPFWindowStart = sample.minPF;
                    majPFWindowStart = sample.majPF;
                }
            });
            return windows;
        }
    }

    class SampleWindow {

        constructor(start, end, cpuUtilization, majPF, minPF, ctxSwitch, allocBytes, allocObjects) {
            this.start = start;
            this.end = end;
            this.cpuUtilization = cpuUtilization;
            this.ctxSwitch = ctxSwitch;
            this.majPF = majPF;
            this.minPF = minPF;
            this.allocBytes = allocBytes;
            this.allocObjects = allocObjects;
        }
    }

    class SampleRenderer {

        constructor(canvas, transform) {
            this.canvas = canvas;
            this.transform = transform;
            this.context = canvas.getContext("2d");
            this.sampleData = new SampleData("");
            this.windowSize = 0;
            this.windows = [];
        }

        setData(sampleData) {
            this.sampleData = sampleData;
            this._refreshWindows();
            this.render();
        }

        render() {
            let viewport = this.transform.getViewport();
            let canvasHeight = this.canvas.height;
            let subWindowHeight = canvasHeight / 5;

            this.transform.applyTo(this.context);
            this.context.translate(0, -this.transform.getTranslationY() / this.transform.getScaleY());

            this.context.fillStyle = "black";
            this.context.fillRect(viewport.left, 0, viewport.width, canvasHeight);

            this.context.fillStyle = "white";
            this.windows.forEach(window => {
                let x = window.start;
                let width = window.end - window.start;
                let height = window.cpuUtilization * subWindowHeight;
                let y = subWindowHeight - height;
                this.context.fillRect(x, y, width, height);
                // console.log("working " + x +"," + y +"," + width + "," + height);

                // render ctx switch window now
                let height2 = window.ctxSwitch / this.sampleData.maxCtxSwitch * subWindowHeight;
                let y2 = subWindowHeight + subWindowHeight - height2;
                this.context.fillRect(x, y2, width, height2 );

                //render maj and min page fault; major red, min green
                this.context.save();
                this.context.fillStyle = "red";
                let height3 = window.majPF / this.sampleData.maxPF * subWindowHeight;
                let y3 = 2 * subWindowHeight + subWindowHeight - height3;
                this.context.fillRect(x, y3, width, height3 );
                this.context.restore();

                this.context.save();
                this.context.fillStyle = "green";
                let height4 = window.minPF / this.sampleData.maxPF * subWindowHeight;
                let y4 = y3 - height4;
                this.context.fillRect(x, y4, width, height4);
                this.context.restore();


                this.context.fillStyle = "white";
                // render allocation bytes
                let height5 = window.allocBytes / this.sampleData.maxAllocBytes * subWindowHeight;
                let y5 = 3 * subWindowHeight + subWindowHeight - height5;
                this.context.fillRect(x, y5, width, height5 );

                // render allocation objects
                let height6 = window.allocObjects / this.sampleData.maxAllocObjects * subWindowHeight;
                let y6 = 4 * subWindowHeight + subWindowHeight - height6;
                this.context.fillRect(x, y6, width, height6 );

            });
        }

        _refreshWindows() {
            this.windows = this.sampleData.windows(this.windowSize);
            console.log(this.windows);
        }
    }

    class State {
        constructor(start_ts, end_ts, state) {
            this.start_ts = start_ts;
            this.end_ts = end_ts;
            this.state = state;
            this.name = THEME.THREAD_STATE_NAME[this.state - 66];
        }
    }

    class StateData {

        constructor(string) {
            this.array = [];
            // this.firstTimestamp = -1;
            this.firstTimestamp = 0;
            this.prev_ts = -1;
            string.split("\n").forEach(s => {
                let a = s.split(", ");
                if (a.length >= 2) {
                    let ts = parseInt(a[0]);
                    let old_state = parseInt(a[1]);
                    let new_state = parseInt(a[2]);
                    if(this.prev_ts === -1){
                        // this.firstTimestamp = ts;
                        // this.prev_ts = 0;
                        this.prev_ts = ts;
                    } else {
                        ts -= this.firstTimestamp;
                        this.array.push(new State(this.prev_ts, ts, old_state));
                        this.prev_ts = ts;
                    }
                }
            })
        }
    }

    class StateRenderer {

        constructor(canvas, transform) {
            this.canvas = canvas;
            this.transform = transform;
            this.context = canvas.getContext("2d");
            this.stateData = new StateData("");
            this.textPool = new TextPool();
        }

        setData(stateData) {
            this.stateData = stateData;
            this.render();
        }

        render() {
            let viewport = this.transform.getViewport();
            let canvasHeight = this.canvas.height;

            this.transform.applyTo(this.context);
            this.context.translate(0, -this.transform.getTranslationY() / this.transform.getScaleY());

            this.context.fillStyle = "black";
            this.context.fillRect(viewport.left, 0, viewport.width, canvasHeight);

            this.stateData.array.forEach(state => {
                this.context.fillStyle = THEME.COLOR_PALETTE_STATE[state.state - 66];
                // this.context.fillStyle = intToRGB(hashCode(THEME.THREAD_STATE_NAME[state.state - 66]));
                // console.log(this.context.fillStyle);
                let x = state.start_ts;
                let width = state.end_ts - state.start_ts;
                let height = canvasHeight;
                let y = 0;

                let scale = this.transform.getScaleX();
                this.context.fillRect(x, y, width, height);
                // console.log(x +"," + y +"," + width + "," + height);
                // console.log(state);

                let cellScreenWidth = scale * width;
                if (cellScreenWidth < 25) {
                    return;
                }
                let name = state.name;
                if (state.textCanvas == null) {
                    state.textCanvas = this.textPool.getOrRasterize(name);
                }

                let nameModelHeight = state.textCanvas.height;
                let nameModelWidth = Math.min(width, state.textCanvas.width / PIXEL_RATIO / scale);

                // Preferred name position - centered on screen with slight offset.
                let nameModelLeft = viewport.left + viewport.width / 2 - 300;

                // Ensure name within left bounds.
                nameModelLeft = Math.max(x, nameModelLeft);
                let nameModelRight = nameModelLeft + nameModelWidth;

                // Ensure name within right bounds.
                nameModelRight = Math.min(x + width, nameModelRight);
                nameModelLeft = nameModelRight - nameModelWidth;

                // let nameModelLeft = this.left;
                // noinspection UnnecessaryLocalVariableJS
                let nameModelTop = 0;

                let nameModelPosition = vec2.fromValues(nameModelLeft, nameModelTop);
                let nameScreenPosition = this.transform.toScreenPosition(nameModelPosition);
                let nameScreenWidth = nameModelWidth * scale;

                this.context.save();
                this.context.setTransform(1, 0, 0, 1, 0, 0);
                this.context.drawImage(
                    state.textCanvas,
                    0, 0, nameScreenWidth, nameModelHeight,
                    nameScreenPosition[0], nameScreenPosition[1], nameScreenWidth, nameModelHeight);
                this.context.restore();
            });
        }
    }

    class AxisRenderer {

        constructor(canvas, transform) {
            this.canvas = canvas;
            this.transform = transform;
            this.context = canvas.getContext("2d");
        }

        render() {
            this.transform.applyTo(this.context);
            // Undo the y translation. We always want the y position to be fixed in screen space. This keeps the axis at the top of the screen.
            this.context.translate(0, -this.transform.getTranslationY() / this.transform.getScaleY());

            this.renderAxisBackground();
            this.renderTickMarks();
        }

        renderTickMarks() {
            let viewport = this.transform.getViewport();

            // Goal of the below calculation: we want to have between 5 to 10 different markers on the screen a time.
            // Allowing each division to decrease in size by a factor of 2 before resizing the division achieves about this.
            // Future enhancements: we'll want to modify the math bere by some constants that will cause the numbers to look a
            // bit nicer. For example, we'll want 250ms to be one of the divisions.
            let divisionFactor = Math.log(viewport.width / 5) / Math.log(2);
            divisionFactor = Math.round(divisionFactor);
            let divisionSize = Math.pow(2, divisionFactor);

            let leftViewPortModelCoordinate = viewport.left;
            let firstMajorDivisionOnScreen = Math.floor(leftViewPortModelCoordinate / divisionSize);
            this.context.lineWidth = THEME.AXIS_LINE_STROKE_WIDTH / this.transform.getScaleX();
            for (let majorDivision = firstMajorDivisionOnScreen; majorDivision < firstMajorDivisionOnScreen + 10; majorDivision++) {
                // note we can't allow the multiplication to affect this.
                this.context.beginPath();
                this.context.moveTo(majorDivision * divisionSize, 0);
                this.context.lineTo(majorDivision * divisionSize, THEME.AXIS_HEIGHT);
                this.context.stroke();
                this.context.closePath();

                for (let minorDivision = 0; minorDivision < 5; minorDivision++) {
                    this.context.beginPath();
                    this.context.moveTo(majorDivision * divisionSize + minorDivision * divisionSize / 5, THEME.AXIS_HEIGHT);
                    this.context.lineTo(majorDivision * divisionSize + minorDivision * divisionSize / 5, .8 * THEME.AXIS_HEIGHT);
                    this.context.stroke();
                    this.context.closePath();
                }

                this.context.fillStyle = THEME.AXIS_LINE_COLOR;
                this.context.save();
                this.context.textBaseline = 'middle';
                this.context.translate(majorDivision * divisionSize, THEME.AXIS_HEIGHT / 2);
                this.context.scale(1 / this.transform.getScaleX(), 1);
                this.context.font = '20px Roboto';
                this.context.fillText("  " + AxisRenderer.formatTime(majorDivision * divisionSize, divisionSize), 0, 0);
                this.context.restore();
            }

            this.context.closePath();
        }

        renderAxisBackground() {
            let viewport = this.transform.getViewport();

            this.context.fillStyle = THEME.AXIS_BACKGROUND_COLOR;
            this.context.fillRect(viewport.left, 0, viewport.width, THEME.AXIS_HEIGHT);
            this.context.strokeStyle = THEME.AXIS_LINE_COLOR;
            this.context.lineWidth = THEME.AXIS_LINE_STROKE_WIDTH;

            // Draw axis from -inf to +inf. For some reason drawing from left to right doesn't work with large numbers.
            this.context.save();
            this.context.setTransform(1, 0, 0, 1, 0, 0);
            this.context.restore();
        }

        static formatTime(time, divisionSize) {
            // TODO: this needs to be improved. For now we just show everything in ns.
            return Math.round(time) + " ns"
        }
    }

    class SampleAxisRenderer {

        constructor(canvas, transform) {
            this.canvas = canvas;
            this.transform = transform;
            this.context = canvas.getContext("2d");
            this.maxCtx = -1;
            this.maxPF = -1;
            this.maxAllocBytes = -1;
            this.maxAllocObjects = -1;
        }

        render() {
            this.transform.applyTo(this.context);
            this.context.translate(-this.transform.getTranslationX() / this.transform.getScaleX(), -this.transform.getTranslationY() / this.transform.getScaleY());
            this.renderAxisBackground();
        }

        renderAxisBackground() {
            // let viewport = this.transform.getViewport();
            let canvasHeight = this.canvas.height;
            let subWindowHeight = canvasHeight / 5;
            let canvasWidth = this.canvas.width;
            console.log("width:" + canvasWidth);

            this.context.fillStyle = THEME.AXIS_BACKGROUND_COLOR;
            this.context.fillRect(0, 0, canvasWidth, canvasHeight);
            this.context.strokeStyle = THEME.AXIS_LINE_COLOR;
            this.context.lineWidth = THEME.AXIS_LINE_STROKE_WIDTH;
            for (let i = 0; i < 6; i++) {
                this.context.beginPath();
                this.context.moveTo(0,i*subWindowHeight);
                this.context.lineTo(canvasWidth,i * subWindowHeight);
                this.context.stroke();
            }

            this.context.fillStyle = THEME.AXIS_LINE_COLOR;
            this.context.font = '20px Roboto';
            this.context.save();
            // this.context.scale(1/2, 1);
            this.context.textBaseline="hanging";
            this.context.textAlign = "right";
            this.context.fillText("100%", canvasWidth, 0);
            this.context.fillText(this.maxCtx, canvasWidth, subWindowHeight);
            this.context.fillText(this.maxPF, canvasWidth, 2 * subWindowHeight);
            this.context.fillText(this.maxAllocBytes, canvasWidth, 3 * subWindowHeight);
            this.context.fillText(this.maxAllocObjects, canvasWidth, 4 * subWindowHeight);
            this.context.textBaseline="bottom";
            this.context.fillText("CPU", canvasWidth, subWindowHeight);
            this.context.fillText("Ctx", canvasWidth, 2 * subWindowHeight);
            this.context.fillText("Page", canvasWidth, 3 * subWindowHeight);
            this.context.fillText("Mem Bytes", canvasWidth, 4 * subWindowHeight);
            this.context.fillText("Mem Objects", canvasWidth, 5 * subWindowHeight);
            this.context.restore();
        }

        setMax(maxCtx, maxPF, maxAllocBytes, maxAllocObjects){
            this.maxCtx = maxCtx;
            this.maxPF = maxPF;
            this.maxAllocBytes = maxAllocBytes;
            this.maxAllocObjects = maxAllocObjects;
        }
    }

    // Handles search.
    class SearchController {

        constructor() {
            this.methodRegistry = new MethodRegistry();
            this.resultsEl = document.getElementById('searchResults');
            this.inputEl = document.getElementById('search');
            this.modalEl = document.getElementById('searchModal');
            this.modalEl.addEventListener('click', () => {
                this._close();
            });
            document.getElementById('searchPanel').addEventListener('click', event => {
                event.stopPropagation();
            });
            this.onSelected = () => {
            };
        }

        onIconClick() {
            this.modalEl.style.display = "inline-block";
            this.inputEl.focus();
        }

        onQuery(query) {
            this.clearResults();
            let methods = this.methodRegistry.search(query, 10);
            for (let method of methods) {
                this.resultsEl.appendChild(this.createResultEl(method));
            }
        }

        setMethodRegistry(methodRegistry) {
            this.methodRegistry = methodRegistry;
        }

        clearResults() {
            while (this.resultsEl.firstChild) {
                this.resultsEl.removeChild(this.resultsEl.firstChild);
            }
        }

        createResultEl(method) {
            let resultEl = document.createElement('div');
            resultEl.innerText = method.shortName;
            resultEl.classList.add('searchResultRow');
            resultEl.addEventListener('click', () => {
                this._select(method)
            });
            return resultEl;
        }

        _close() {
            this.modalEl.style.display = "none";
        }

        _select(method) {
            this.inputEl.value = "";
            this.clearResults();
            this.onSelected(method);
            this._close();
        }
    }

    // Top level controller. Currently all DOM input funnels through this class.
    class Controller {

        constructor() {
            let canvas = document.getElementById('canvas');
            let axisCanvas = document.getElementById('axisCanvas');
            let sampleCanvas = document.getElementById('sampleCanvas');
            let minimapCanvas = document.getElementById('minimapCanvas');
            this.transform = new Transform();
            this.loadingController = new LoadingController();
            this.searchController = new SearchController();
            this.canvasTraceRenderer = new CanvasTraceRenderer(canvas, this.transform);
            this.axisRenderer = new AxisRenderer(axisCanvas, this.transform);
            this.sampleAxisRenderer = new SampleAxisRenderer(sampleAxisCanvas, this.transform);
            this.sampleRenderer = new SampleRenderer(sampleCanvas, this.transform);
            this.stateRenderer = new StateRenderer(stateCanvas, this.transform);
            this.minimapRenderer = new MinimapRenderer(minimapCanvas, this.transform);
            this.detailsController = new DetailsController();

            this.detailsController.onFocus = call => {
                this._focusCall(call);
                this._refreshCanvas();
            };
            this.searchController.onSelected = method => {
                let firstCall = method.getCallAt(0);
                this._selectCall(firstCall);
                this._refreshCanvas();
            }
        }

        loadEmbeddedData() {
            this.loadSampleData();
            this.loadTraceData();
            this.loadStateData();
        }

        loadSampleData() {
            let sampleDataString = document.getElementById("sampledata").innerText;
            if (sampleDataString === "TRACE_SAMPLE_PLACEHOLDER") {
                return;
            }

            let sampleData = new SampleData(sampleDataString);
            this.sampleRenderer.setData(sampleData);
            this.sampleAxisRenderer.setMax(sampleData.maxCtxSwitch, sampleData.maxPF, sampleData.maxAllocBytes, sampleData.maxAllocObjects);
            this.sampleAxisRenderer.render();
        }

        loadStateData() {
            let stateDataString = document.getElementById("statedata").innerText;
            if (stateDataString === "TRACE_SAMPLE_PLACEHOLDER") {
                return;
            }

            let stateData = new StateData(stateDataString);
            this.stateRenderer.setData(stateData);
        }


        loadTraceData() {
            let traceDataString = document.getElementById("tracedata").innerText;
            if (traceDataString === "TRACE_DATA_PLACEHOLDER") {
                return;
            }
            let traceDataBytes = new TextEncoder().encode(traceDataString);
            this._loadBytes(traceDataBytes)
        }

        onFileChange(file) {
            let fileReader = new FileReader();
            fileReader.onload = e => {
                let bytes = new Uint8Array(e.target.result);
                this._loadBytes(bytes)
            };
            fileReader.readAsArrayBuffer(file);
        }

        onKeyPress(keycode) {
            if (document.activeElement === document.getElementById('search')) {
                return false;
            }
            if (this.transform.onKeyPress(keycode)) {
                this._refreshCanvas();
                return true;
            }
            return false
        }

        onMouseWheel(event) {
            this.transform.onMouseWheel(event);
            this._refreshCanvas();
        }

        onCanvasResize(bounds) {
            this.transform.setScreenViewport(bounds);
            this._refreshCanvas();
        }

        onQuery(query) {
            this.searchController.onQuery(query);
        }

        onSearchIconClick() {
            this.searchController.onIconClick();
        }

        onClick(event) {
            let modelCoordinate = this.transform.toModelPositionFromClick(event);
            let call = this.canvasTraceRenderer.getCallAtCoordOrNull(modelCoordinate[0], modelCoordinate[1]);
            if (call !== null) {
                this._selectCall(call);
                this._refreshCanvas();
                return true;
            }
            return false;
        }

        _loadBytes(bytes) {
            this.canvasTraceRenderer.clear();
            let traceDataLoader = new TraceDataProcessor(bytes);
            let methodRegistry = new MethodRegistry();
            traceDataLoader.onPush = call => {
                methodRegistry.pushCall(call);
            };
            traceDataLoader.onPop = call => {
                this.canvasTraceRenderer.addCall(call);
                methodRegistry.popCall(call);
            };
            traceDataLoader.onProgress = this.loadingController.onProgress.bind(this.loadingController);
            traceDataLoader.onDone = () => {
                this.searchController.setMethodRegistry(methodRegistry);
                this.minimapRenderer.setMethodRegistry(methodRegistry);
                this.detailsController.setMethodRegistry(methodRegistry);
                this.canvasTraceRenderer.focusOnRegistry(methodRegistry);
                this.canvasTraceRenderer.setMaxZoomOut(methodRegistry);
                this.loadingController.onDone();
                this._refreshCanvas();
            };
            this.loadingController.onStart(bytes.length);
            traceDataLoader.load();
        }

        _focusCall(call) {
            this.canvasTraceRenderer.focus(call);
        }

        _selectCall(call) {
            this.canvasTraceRenderer.selectCall(call);
            this.detailsController.selectCall(call);
        }

        _refreshCanvas() {
            this.canvasTraceRenderer.render();
            this.sampleRenderer.render();
            this.stateRenderer.render();
            this.sampleAxisRenderer.render();
            this.axisRenderer.render();
            this.minimapRenderer.render();
        }
    }

    let controller = new Controller();

    function resizeCanvas() {
        let resize = (canvas) => {
            canvas.width = canvas.getBoundingClientRect().width * PIXEL_RATIO;
            canvas.height = canvas.getBoundingClientRect().height * PIXEL_RATIO;
        };
        let canvas = document.getElementById('canvas');
        resize(canvas);
        resize(document.getElementById('sampleCanvas'));
        resize(document.getElementById('sampleAxisCanvas'));
        resize(document.getElementById('stateCanvas'));
        resize(document.getElementById('axisCanvas'));
        resize(document.getElementById('minimapCanvas'));
        controller.onCanvasResize(new Rect(0, 0, canvas.width, canvas.height));
    }

    resizeCanvas();

    controller.loadEmbeddedData();

    document.getElementById('file').addEventListener('change', event => {
        let file = event.target.files[0];
        controller.onFileChange(file);
    }, false);

    window.addEventListener('resize', () => {
        resizeCanvas();
    });

    document.getElementById('canvas').addEventListener('mousewheel', event => {
        event.preventDefault();
        event.stopImmediatePropagation();
        controller.onMouseWheel(event);
    });

    document.getElementById('canvas').addEventListener('click', event => {
        controller.onClick(event);
    });

    document.getElementById('search').addEventListener('keyup', event => {
        controller.onQuery(event.srcElement.value);
    });

    document.addEventListener('keydown', event => {
        if (document.activeElement === document.getElementById('search')) {
            return false;
        }
        if (controller.onKeyPress(event.keyCode)) {
            event.preventDefault();
            event.stopImmediatePropagation();
        }
    }, false);

    document.getElementById('searchIcon').addEventListener('click', event => {
        controller.onSearchIconClick();
    });

    document.getElementById('searchModal').addEventListener('mousewheel', event => {
        event.preventDefault();
    });
</script>

</body>
</html>
